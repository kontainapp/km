#
# Kontain Monitor Azure Pipeline definition
#
name: ci-$(BuildID) $(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
    - master
    - ci/* # prefix ci/ to force CI on every push. e.g. ci/msterin/test-azure-devops/ci
  paths:
    exclude:
    - README.md
    - docs/*

pr:
  - master

variables:
  vmImage: "ubuntu-18.04"
  pod_test_km: "pod/test-km-$(buildenv.type)-ci-$(Build.BuildId)"
  pod_test_node: "pod/test-node-$(buildenv.type)-ci-$(Build.BuildId)"
  pod_test_python: "pod/test-python-$(buildenv.type)-ci-$(Build.BuildId)"
  dtype: "$(buildenv.type)"


strategy:
  matrix:
    fedora:
      buildenv.type: fedora
    # Note: DTYPE=$(buildenv.type) below is needed only for Ubuntu; fedota is the default
    # ubuntu:
    #   buildenv.type: ubuntu
pool:
  vmImage: $(vmImage)

steps:
  - checkout: self
    submodules: true

  - bash: |
      echo ====Environment info===
      echo "SHA: $(git rev-parse HEAD)"
      echo "=== Last 10 commits:"
      git log -n 10 --graph --pretty=format:'%h% %d %s %cr %ce'
      echo "=== VM/OS:"
      cat /proc/version
      echo "=== Docker version:"
      docker version
      echo  =======================
      env
    displayName: Print build environment info

  - bash: make -C cloud/azure login-cli \
          SP_APPID=$(SP_appId) SP_PASSWORD=$(SP_password) SP_TENANT=$(SP_tenant) SP_DISPLAYNAME=$(SP_displayName)
    displayName: Login to Azure, container registry and Kubernetes

  - bash: |
      set -x -e
      make -C tests pull-buildenv-image
      make -j withdocker
      make -C tests testenv-image push-testenv-image IMAGE_VERSION=CI-$(Build.BuildId)
    displayName: Set KM build environment, build KM, create and push KM Test container to registry

  - bash: |
      set -x -e
      make -C tests test-withk8s IMAGE_VERSION=CI-$(Build.BuildId)
      kubectl wait --for=condition=Ready --timeout=2m $(pod_test_km)
      kubectl logs -f $(pod_test_km)
      if [ $(kubectl get $(pod_test_km) -o 'jsonpath={..terminated.exitCode}') != 0 ] ; then exit 1; fi
    displayName: Run KM tests on Kubernetes
    timeoutInMinutes: 5

  - bash: |
      set -x -e
      make -C payloads/node pull-buildenv-image all
      make -C payloads/node push-testenv-image IMAGE_VERSION=CI-$(Build.BuildId)
    displayName: Set Node.km build environment, build Node.km, create and push Node.km Test container to registry

    # Node test. TODO - use Azure pipeline templates to drop cut-n-paste, and/or wrap this in a checked in script
  - bash: |
      set -x -e
      make -C payloads/node test-withk8s IMAGE_VERSION=CI-$(Build.BuildId)
      kubectl wait --for=condition=Ready --timeout=2m $(pod_test_node)
      kubectl logs -f $(pod_test_node)
      if [ $(kubectl get $(pod_test_node) -o 'jsonpath={..terminated.exitCode}') != 0 ] ; then exit 1; fi
    displayName: Run Node.km tests on Kubernetes
    timeoutInMinutes: 5

  - bash: |
      set -x
      make -C cloud/azure ci-image-purge CI_IMAGE_DRY_RUN=""
      # TODO - if the **test** failed (especially with kmcore), we want to keep these pods for a few days
      # Setting vars doc: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables
      echo "======= Printing statuses and cleaning up ======"
      for p in $(pod_test_node) $(pod_test_km) ; do  kubectl get $p -o json; kubectl delete $p; done
      rm -f ~/.kube/config
      docker logout
      az logout
    condition: always()
    displayName: Cleanup test job,  purge old test images and logout
