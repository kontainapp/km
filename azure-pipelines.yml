#
# Kontain Monitor Azure Pipeline definition
#
name: ci-$(BuildID) $(Date:yyyyMMdd)$(Rev:.r)

trigger:
  branches:
    include:
    - master
    - ci/* # prefix ci/ to force CI on every push. e.g. ci/msterin/test-azure-devops
  paths:
    exclude:
    - README.md
    - docs/*

pr:
  - master

variables:
  vmImage: "ubuntu-18.04"
  pod_test_km: "pod/test-km-$(buildenv.type)-ci-$(Build.BuildId)"
  pod_test_node: "pod/test-node-$(buildenv.type)-ci-$(Build.BuildId)"
  pod_test_python: "pod/test-python-$(buildenv.type)-ci-$(Build.BuildId)"
  # Helper vars for the build. Note that in Azure pipeline this also makes UPPCASE_NAME
  # of a var exposed in environment. E.g. 'dtype=fedora' means all shells will see DTYPE=fedora.
  dtype: $(buildenv.type) # until we add other distros, this always maps to DTYPE=fedora (see 'strategy' below)
  image_version: ci-$(Build.BuildId) # defaut IMAGE_VERSION setting for all commands

strategy:
  matrix:
    fedora:
      buildenv.type: fedora
    # Note: DTYPE=$(buildenv.type) below is needed only for Ubuntu; fedora is the default
    # ubuntu:
    #   buildenv.type: ubuntu
pool:
  vmImage: $(vmImage)

steps:
  - checkout: self
    submodules: true

  - bash: |
      echo ====Environment info===
      echo "SHA: $(git rev-parse HEAD)"
      echo "=== Last 10 commits:"
      git log -n 10 --graph --pretty=format:'%h% %d %s %cr %ce'
      echo "=== VM/OS:"
      cat /proc/version
      echo "=== Docker version:"
      docker version
      echo  =======================
      env
    displayName: Print build environment info

  - bash: make -C cloud/azure login-cli
      SP_APPID=$(SP_appId) SP_PASSWORD=$(SP_password) SP_TENANT=$(SP_tenant) SP_DISPLAYNAME=$(SP_displayName)
    displayName: Login to Azure, container registry and Kubernetes

  - bash: |
      set -x -e
      make -C tests pull-buildenv-image IMAGE_VERSION=latest
      make -j withdocker
      make -C tests testenv-image push-testenv-image
    displayName: KM test - set build environment, build, create test container and push it to registry

  - bash: make -C cloud/azure ci-run-tests LOCATION=tests POD_NAME=$(pod_test_km)
    displayName: Run KM tests on Kubernetes
    timeoutInMinutes: 10

  - bash: make -C cloud/azure ci-prepare-testenv LOCATION=payloads/python
    displayName: Python.km test - set build environment, build, create test container and push it to registry

  - bash: make -C cloud/azure ci-run-tests LOCATION=payloads/python POD_NAME=$(pod_test_python)
    displayName: Run Python.km tests on Kubernetes
    timeoutInMinutes: 5

  - bash: make -C cloud/azure ci-prepare-testenv LOCATION=payloads/node
    displayName: Node.km test - set build environment, build, create test container and push it to registry

  - bash: make -C cloud/azure ci-run-tests LOCATION=payloads/node POD_NAME=$(pod_test_node)
    displayName: Run Node.km tests on Kubernetes
    timeoutInMinutes: 5

  - bash: |
      set -x
      make -C cloud/azure ci-image-purge CI_IMAGE_DRY_RUN=""
      # TODO - if the **test** failed (especially with kmcore), we want to keep these pods for a few days
      # Setting vars doc: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables
      echo "======= Printing statuses and cleaning up ======"
      for p in $(pod_test_km) $(pod_test_python) $(pod_test_node); do  kubectl get $p -o json; kubectl delete $p; done
      rm -f ~/.kube/config
      az logout
    condition: always()
    displayName: Cleanup test job,  purge old test images and logout
