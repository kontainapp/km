trigger:
  - master
  - ci/* # prefix ci/ to force CI on every push. e.g. ci/msterin/test-azure-devops/ci
pr:
  - master

variables:
  azureSubscriptionEndpoint: kontainAzureResourceManageServiceConnection
  azureContainerRegistry: kontainkubecr
  azureResourceGroup: kontainKubeRG
  kubernetesCluster: kontainKubeCluster
  registry: "kontainkubecr.azurecr.io"
  registrySC: "kontainkubecr_service_connection"
  k8sSC: "CD-to-k8s"
  vmImage: "ubuntu-16.04"

strategy:
  matrix:
    fedora:
      buildenv.type: fedora
    # ubuntu:
    #   buildenv.type: ubuntu
pool:
  vmImage: $(vmImage)

steps:
  - checkout: self
    submodules: true

  - task: Docker@2
    inputs:
      command: login
      containerRegistry: $(registrySC)
    displayName: Login to registry $(registry)

  - bash: |
      set -e
      echo ====Environment info===
      echo "SHA: $(git rev-parse HEAD)"
      echo "=== Last 10 commits:"
      git log -n 10 --graph --pretty=format:'%h% %d %s %cr %ce'
      echo "=== VM/OS:"
      cat /proc/version
      echo "=== Docker version:"
      docker version
      echo "=== ENV:"
      env
      echo  =======================
    displayName: Print build environment info

  - bash: |
      set -e -x
      make -C tests pull-buildenv-image
      make -j withdocker DTYPE=$(buildenv.type)
      echo "=== bats tests/bats-$(buildenv.type)-job.yaml : ==="
      m4 -D BUILD_ID=$(Build.BuildId) -D DTYPE_VALUE=$(buildenv.type) -D REGISTRY=$(azureContainerRegistry) tests/bats-job.yaml | tee tests/bats-$(buildenv.type)-job.yaml
    displayName: Build KM and KM tests using docker ($(buildenv.type))

  - bash: make -C tests testenv-image push-testenv-image IMAGE_VERSION=CI-$(Build.BuildId) DTYPE=$(buildenv.type)
    displayName: Create and push KM Test container to registry $(registry)

  - task: Kubernetes@1
    inputs:
      connectionType: Kubernetes Service Connection
      azureSubscriptionEndpoint: $(azureSubscriptionEndpoint)
      azureResourceGroup: $(azureResourceGroup)
      kubernetesCluster: $(kubernetesCluster)
      kubernetesServiceEndpoint: $(k8sSC)
      command: apply
      arguments: -f tests/bats-$(buildenv.type)-job.yaml
    displayName: Start tests on Kubernetes cluster $(kubernetesCluster)

  - task: Kubernetes@1
    inputs:
      connectionType: Kubernetes Service Connection
      azureSubscriptionEndpoint: $(azureSubscriptionEndpoint)
      azureResourceGroup: $(azureResourceGroup)
      kubernetesCluster: $(kubernetesCluster)
      kubernetesServiceEndpoint: $(k8sSC)
      command: wait
      arguments: --timeout 1800s --for=condition=complete job/bats-$(buildenv.type)-$(Build.BuildId)
    displayName: Wait for tests to complete or fail

  - task: Kubernetes@1
    condition: always()
    inputs:
      connectionType: Kubernetes Service Connection
      azureSubscriptionEndpoint: $(azureSubscriptionEndpoint)
      azureResourceGroup: $(azureResourceGroup)
      kubernetesCluster: $(kubernetesCluster)
      kubernetesServiceEndpoint: $(k8sSC)
      command: logs
      arguments: jobs/bats-$(buildenv.type)-$(Build.BuildId)
    displayName: Get tests results

  - task: Kubernetes@1
    condition: always()
    inputs:
      connectionType: Kubernetes Service Connection
      azureSubscriptionEndpoint: $(azureSubscriptionEndpoint)
      azureResourceGroup: $(azureResourceGroup)
      kubernetesCluster: $(kubernetesCluster)
      kubernetesServiceEndpoint: $(k8sSC)
      command: delete
      arguments: jobs/bats-$(buildenv.type)-$(Build.BuildId)
    displayName: Delete Kubernetes test job bats-$(Build.BuildId)

  - script: |
      echo '****** TODO print SHA so we can rebuild, and remove image $(registry)/test-km-$(buildenv.type):CI-$(Build.BuildId)'
    condition: always()
    displayName: Cleanup test image in registry (TODO)
