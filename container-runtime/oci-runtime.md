# Introduction

We have chosen to use the open source crun runtime to support running programs as kontain payloads in a container.
crun is written in C and has better performance than what is currently used, runc.
crun will probably be the default container runtime for fedora.
This source code is forked from https://github.com/containers/crun.git and the intent is to keep our copy current with
the mainline of development.  In addition if any of our changes are generally useful we should submit a PR to the mainline.

Kontain's crun is kept in the km source tree as a submodule under the directory container-runtime/crun.

Kontain's variant of crun is named krun.

## Added functionality

krun ensures that the kontainer entry point is run within km.  The required km, needed libraries, and devices are
automatically added to the kontainer without additional krun command line arguments.  Currently the following things
are done:

- automatically bind mounts km into the container
- automatically add the /dev/kvm and /dev/kkm devices to the container if they are present outside the container
- the container entry point is run with km
- certain approved container entry points can be run without km to perform operations for diagnosing problems

Kontain specific behaviour in crun is provided when crun is started with the program name krun.

## Allowing container entry points to run without km

The krun exec command can allow entry points to run as a regular linux process without Kontain vm encapsulation if the entry point is configured in an exception file.
The file is named /var/lib/krun/config and must be inside the container's filesystem namespace.
The file contains entries that occupy a single line.  Each line is 3 fields separated by a colon (":").
The fields are:
- a regular expression the entry point name may match.
- If there is a match the next field specifies the path of the program that will be run.
- The third field contains the 256 bit hash, generated by the linux sha256sum program, of the contents of the file specified in the second field.
  The file will be read and the hash will be recomputed and verified against the contents of this field.
  If they differ the krun exec request will fail.  If the the hashes are the same the program file from the second field will be run in the container.

## Additional work needed

- container start semantics require the container to pause just before the entrypoint is ready to run and then wait until told to start.
  The entry point to a kontain container is km and km has precursor work to do before the payload is ready to go.  There needs to be a change
  to allow km to be started, have it pause just before payload entry and then wait there (as opposed to inside of krun) for the
  start operation.
- crun logging needs to be improved to allow others to debug changes to crun.  It would also be helpful to explain why some things in the
  code are being done.  For example why logging is switched to stderr despite other forms of logging requested with crun's invocation arguments.

# Building

At the top of the km source tree:

```bash
make -C container-runtime clobber
make -C container-runtime all
```

The crun Makefiles are generated by automake and they contain absolute paths.
crun Makefiles generated inside a container contain different absolute paths from those generated outside of a container
Makefiles generated in a container will not work outside a container and vice versa.  Unless the paths are the same in and outside
of the container.  You will need to rebuild the Makefile when switching between inside and outside a container operation.
Also parallel make with crun will cause compilation errors sometimes because the Makefiles generated by automake have no dependencies on
the artifacts generated by the Makefile's for the submodules used by crun.  The build of crun seems to run concurrently with the
build of crun's needed submodules resulting in header files generated in a submodule sometimes not being built yet.

## Dependencies

crun is dependent on some other packages to build.  It is probably best to look in the crun directory at the file README.md.
The dependencies for various systems are listed.
The required packages are expected to be in the kontain buildenv.  As more dependencies appear they will need to be added to
tests/buildenv-fedora.dockerfile and container-runtime/test_remote.py.

# Testing

crun has its own simple test suite written in python.  It does not test crun within a docker or podman or kubernetes.
It builds a simple container from scratch and then starts crun/krun within that container to test it.

To test on your workstation:

```bash
make -C container-runtime test
```

As we add features to krun, we also write additional python tests to test the new krun specific features.
krun specific tests must be skipped when we test crun.  The python test suite has provisions for skipping tests
when some feature is missing from the test system and kontain uses that to skip krun specific tests when testing
the crun variant.
The crun tests reside in container-runtime/crun/tests directory.

It is currently not possible to test crun/krun in a container using the python based crun tests.  crun creates namespaces which would need to
exist inside of namespaces created for the container and there seem to be conflicts that have not been resolved.
crun and krun should work fine as runtimes for docker and podman, and I think kubernetes.

# Debugging

The logging facilities are controlled with 2 command line arguments

--log=[ pathtofile | file:filepath | syslog:id | journald: ]
The log flag controls the destination of the logging stream.  You can specify the name of the file the log stream is to go to, or specify "syslog:"
to have the logging stream directed to the syslog daemon, or specify "journald:" to have the log stream directed to the journald.
If you specify a pathtofile or file:filepath to be the destination for the logging stream, the file must exist inside of the container.
To use journald, crun must have been compiled and linked with the systemd library.
The default logging target is stderr.
--log-format=[json | text]
json specifies that the message is to be made into a json string containing the message, a level consisting of "warning" or "error", and a timestamp.
text specifies that the message is to be written as plain text.  If logging is to a tty the message will contain a timestamp, otherwise no timestamp.

It should be noted that crun will in some places set the logging target back to stderr so if you think a trace might be missing it may be on stderr.
Also note that the logging functions can destroy the value in errno so be careful where you place calls to the tracing functions libcrun_warning() and
libcrun_error().
Also note that there may be several copies of crun (via fork()) with the same top level parent process, but the logging functions do not log the
pid of the process logging things so you may see things in the log whose order is confusing.

# Configure docker to use krun as a runtime

Edit the file: /etc/docker/daemon.json using sudo

Add lines like the following with the appropriate paths:

```txt
{
  "runtimes": {
    "krun": {
      "path": "/opt/kontain/bin/krun"
    },
    "crun": {
      "path": "/opt/kontain/bin/crun"
    }
  }
}
```
Then restart docker:

```bash
systemctl reload-or-restrt docker.service
```

# Configure podman to use krun as a runtime

The script podman_config.sh in this directory is provided to configure podman and your system to run kontain containers using podman and krun.
The script currently changes ~/.config/containers/containers.conf, and adds some minor selinux policy changes to allow krun and km to work.
You can also place the podman configuration changes in /usr/share/containers/containers.conf, or /etc/containers/containers.conf


# Running a kontainer using the krun runtime

Once you have configured docker or podman to use the krun runtime you can run a kontainer using the docker or podman commands as follows:

## docker

docker run --runtime=krun kontain_imagename

## podman

pdoman run --runtime=krun kontain_imagename

Instructions for building a kontain image can be found in Kontain User Guide (see Readme.md in the top of KM repo)

# Working with th crun source

We place our changes to crun in the kontainapp/crun repository in a branch named krun.  We keep our work in a branch to make
syncing our copy of the crun repository from upstream easier.
When making changes to krun, do the following:

```
cd container-runtime/crun
git checkout krun
git checkout -b krun/yourname/what-you-are-fixing
```

Make your changes to the source code and then test them.  Once you are satisfied with the changes push them to our github repository for review before merging.

```
git push origin krun/yourname/what-you-are-fixing
```

After you push your krun changes to the kontainapp/crun repository, you will need to go to github and chose a target branch for the PR.
Be sure you select our repository (not the containers/crun repository) for the merge target.  And, ensure that the changes go into the krun branch, not main or master.

Once the PR is created the crun github workflows will run.  You need to check that the "Test" workflow succeeds.
If it fails, you need to find and fix the problem.  It should be noted that this workflow does check coding style.  We need to follow the containers/crun
coding style.
There is also an "Artifact" workflow which fails in the kontainapp/crun repository.  This needs to be fixed.

Once the crun Test workflow is successful the changes need to be approved using github.
Complete the code review on github and get approval to merge the changes.  Once approved, merge the changes on github.

Once your changes are in the kontain crun repository, km needs be updated so those changes are being used in what is built in the kontainapp/km
source.

```
cd container-runtime/crun
git fetch remote
git checkout krun
cd ../..
git checkout -b yourname/use-the-latest-krun
git add container-runtime/crun
git commit
git push origin yourname/use-the-latest-krun
```

Once your changes have been reviewed and approved, use github to merge these.

# Refreshing our forked copy of crun from the upstream crun repository

Ocassionally we need to pull the latest version of crun from the upstream repository into our repository and then rebase our
current work onto the top of the latest crun source.
Following are the steps I use:

```
cd container-runtime/crun
git remote add upstream https://github.com/containers/crun.git
git remote -v
git fetch upstream
git checkout main
git rebase upstream/main
```
There should be no rebase conflicts for the main crun branch since we don't do development work there.

Next rebase our krun branch on top of the main crun branch.  If necessary fix the rebase conflicts.

```
git checkout krun
git rebase main krun
git rebase --continue
```

Verify that the simple crun tests work.

```
cd ../..
make -C container-runtime clobber
make -C container-runtime
make -C km
make -C container-runtime test
```

Then push our rebased krun changes back to our crun repository

```
cd container-runtime/crun
git push origin krun
```

The above "git push" will start the crun github workflows which build and test the changes.

I'm not sure if we want to review the "rebase changes".

As a result of the rebase, there may be changes to the crun github workflows which we inherit and they may fail.
If they do fail, we need to fix the problems.

# The crun github workflows

In the directory container-runtime/crun/.github/workflows there are 2 workflow definitions:

```
[paulp@work km]$ cd container-runtime/crun/.github/workflows/
[paulp@work workflows]$ ls -l
total 12
-rw-rw-r--. 1 paulp paulp 2479 Jul 14 16:41 release.yaml
-rw-rw-r--. 1 paulp paulp 5774 Jul 14 16:41 test.yaml
[paulp@work workflows]$
```

These workflows are executed by github every time a kontainapp/crun change is pushed to our github repository.

The test.yaml workflow should succeed.  If it doesn't it needs to be fixed.
The release.yaml workflow is broken (as of July 16, 2021) and we need to fix it eventually.
