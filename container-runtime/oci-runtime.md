# Introduction

We have chosen to use the open source crun runtime to support running programs as kontain payloads in a container.
crun is written in C and has better performance than what is currently used, runc.
crun will probably be the default container runtime for fedora.
This source code is forked from https://github.com/containers/crun.git and the intent is to keep our copy current with
the mainline of development.  In addition if any of our changes are generally useful we should submit a PR to the mainline.

Kontain's crun is kept in the km source tree as a submodule under the directory container-runtime/crun.

Kontain's variant of crun is named krun.

## Added functionality

krun ensures that the kontainer entry point is run within km.  The required km, needed libraries, and devices are
automatically added to the kontainer without additional krun command line arguments.  Currently the following things
are done:

- automatically bind mounts km and libc.so into the container
- automatically add the /dev/kvm and /dev/kkm devices to the container if they are present outside the container
- the container entry point is run with km 
- certain approved container entry points can be run without km to perform operations for diagnosing problems

Kontain specific behaviour in crun is provided when crun is started with the program name krun.

## Allowing container entry points to run without km

The krun exec command can allow entry points to run as a regular linux process without Kontain vm encapsulation if the entry point is configured in an exception file.
The file is named /var/lib/krun/config and must be inside the container's filesystem namespace.
The file contains entries that occupy a single line.  Each line is 3 fields separated by a colon (":").
The fields are:
- a regular expression the entry point name may match.
- If there is a match the next field specifies the path of the program that will be run.
- The third field contains the 256 bit hash, generated by the linux sha256sum program, of the contents of the file specified in the second field.
  The file will be read and the hash will be recomputed and verified against the contents of this field.
  If they differ the krun exec request will fail.  If the the hashes are the same the program file from the second field will be run in the container.

## Additional work needed

- container start semantics require the container to pause just before the entrypoint is ready to run and then wait until told to start.
  The entry point to a kontain container is km and km has precursor work to do before the payload is ready to go.  There needs to be a change
  to allow km to be started, have it pause just before payload entry and then wait there (as opposed to inside of krun) for the
  start operation.
- crun logging needs to be improved to allow others to debug changes to crun.  It would also be helpful to explain why some things in the
  code are being done.  For example why logging is switched to stderr despite other forms of logging requested with crun's invocation arguments.

# Building

At the top of the km source tree:

```bash
make -C container-runtime clobber
make -C container-runtime all
```

The crun Makefiles are generated by automake and they contain absolute paths.
crun Makefiles generated inside a container contain different absolute paths from those generated outside of a container
Makefiles generated in a container will not work outside a container and vice versa.  Unless the paths are the same in and outside
of the container.  You will need to rebuild the Makefile when switching between inside and outside a container operation.
Also parallel make with crun will cause compilation errors sometimes because the Makefiles generated by automake have no dependencies on
the artifacts generated by the Makefile's for the submodules used by crun.  The build of crun seems to run concurrently with the
build of crun's needed submodules resulting in header files generated in a submodule sometimes not being built yet.

## Dependencies

crun is dependent on some other packages to build.  It is probably best to look in the crun directory at the file README.md.
The dependencies for various systems are listed.
The required packages are expected to be in the kontain buildenv.  As more dependencies appear they will need to be added to
tests/buildenv-fedora.dockerfile and container-runtime/test_remote.py.

# Testing

crun has its own simple test suite written in python.  It does not test crun within a docker or podman or kubernetes.
It builds a simple container from scratch and then starts crun/krun within that container to test it.

To test on your workstation:

```bash
make -C container-runtime test
```

As we add features to krun, we also write additional python tests to test the new krun specific features.
krun specific tests must be skipped when we test crun.  The python test suite has provisions for skipping tests
when some feature is missing from the test system and kontain uses that to skip krun specific tests when testing
the crun variant.
The crun tests reside in container-runtime/crun/tests directory.

It is currently not possible to test crun/krun in a container using the python based crun tests.  crun creates namespaces which would need to
exist inside of namespaces created for the container and there seem to be conflicts that have not been resolved.
crun and krun should work fine as runtimes for docker and podman, and I think kubernetes.

# Debugging

The logging facilities are controlled with 2 command line arguments

--log=[ pathtofile | file:filepath | syslog:id | journald: ]
The log flag controls the destination of the logging stream.  You can specify the name of the file the log stream is to go to, or specify "syslog:"
to have the logging stream directed to the syslog daemon, or specify "journald:" to have the log stream directed to the journald.
If you specify a pathtofile or file:filepath to be the destination for the logging stream, the file must exist inside of the container.
To use journald, crun must have been compiled and linked with the systemd library.
The default logging target is stderr.
--log-format=[json | text]
json specifies that the message is to be made into a json string containing the message, a level consisting of "warning" or "error", and a timestamp.
text specifies that the message is to be written as plain text.  If logging is to a tty the message will contain a timestamp, otherwise no timestamp.

It should be noted that crun will in some places set the logging target back to stderr so if you think a trace might be missing it may be on stderr.
Also note that the logging functions can destroy the value in errno so be careful where you place calls to the tracing functions libcrun_warning() and
libcrun_error().
Also note that there may be several copies of crun (via fork()) with the same top level parent process, but the logging functions do not log the
pid of the process logging things so you may see things in the log whose order is confusing.

# Configure docker to use krun as a runtime

Edit the file: /etc/docker/daemon.json using sudo

Add lines like the following with the appropriate paths:

```txt
{
  "runtimes": {
    "krun": {
      "path": "/opt/kontain/bin/krun"
    },
    "crun": {
      "path": "/opt/kontain/bin/crun"
    }
  }
}
```
Then restart docker:

```bash
systemctl reload-or-restrt docker.service
```

# Configure podman to use krun as a runtime

Edit the file /usr/share/containers/containers.conf using sudo.

Add the following (with the appropriate path to krun) under the section [engine.runtimes]:

```txt
krun = [
   "/opt/kontain/bin/krun",
]
```

The default runtime can be specified with the following directive:

runtime = "krun"

# Running a kontainer using the krun runtime

Once you have configured docker or podman to use the krun runtime you can run a kontainer using the docker or podman commands as follows:

## docker

docker run --runtime=krun kontain_imagename

## podman

pdoman run --runtime=krun kontain_imagename

Instructions for building a kontain image can be found in the file km-releases/GettingStarted.md in the "Validate" section of the document.
